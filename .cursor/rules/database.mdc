---
description: Database rules for the application.
globs:
  - 'prisma/schema.prisma'
  - 'src/lib/prisma.ts'
  - 'src/db/**/*'
  - '**/*.prisma'
  - '**/*.sql'
alwaysApply: false
---

# Database Rules

## Prisma Schema

### Model Definitions

```prisma
// ✅ Well-structured model with proper types
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  posts     Post[]
  profile   Profile?

  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String
  published Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String

  @@map("posts")
}
```

### Enums

```prisma
// ✅ Use enums for constrained values
enum Role {
  USER
  ADMIN
  MODERATOR
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}
```

### Indexes

```prisma
// ✅ Add indexes for performance
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String

  @@index([email])
  @@index([createdAt])
}

model Post {
  id        String   @id @default(cuid())
  title     String
  published Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([published, createdAt])
  @@index([authorId])
}
```

## Database Operations

### Prisma Client Usage

```typescript
// ✅ Use Prisma client with proper error handling
import { prisma } from '@/lib/prisma';

export async function createUser(data: CreateUserData): Promise<User> {
  try {
    const user = await prisma.user.create({
      data: {
        email: data.email,
        name: data.name,
        role: data.role || 'USER',
      },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true,
      },
    });

    return user;
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002') {
        throw new Error('User with this email already exists');
      }
    }
    throw error;
  }
}
```

### Query Optimization

```typescript
// ✅ Optimize queries with select and include
export async function getUsersWithPosts(): Promise<UserWithPosts[]> {
  return await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
      posts: {
        select: {
          id: true,
          title: true,
          published: true,
        },
        where: {
          published: true,
        },
        orderBy: {
          createdAt: 'desc',
        },
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });
}
```

### Transactions

```typescript
// ✅ Use transactions for related operations
export async function createUserWithProfile(data: CreateUserData): Promise<User> {
  return await prisma.$transaction(async tx => {
    const user = await tx.user.create({
      data: {
        email: data.email,
        name: data.name,
      },
    });

    await tx.profile.create({
      data: {
        userId: user.id,
        bio: data.bio || '',
        avatar: data.avatar,
      },
    });

    return user;
  });
}
```

## Type Safety

### Generated Types

```typescript
// ✅ Use Prisma generated types
import { User, Post, Prisma } from '@prisma/client';

// Type for user with posts
type UserWithPosts = Prisma.UserGetPayload<{
  include: { posts: true };
}>;

// Type for creating a user
type CreateUserInput = Prisma.UserCreateInput;

// Type for updating a user
type UpdateUserInput = Prisma.UserUpdateInput;
```

### Custom Types

```typescript
// ✅ Create custom types for business logic
export interface UserFilters {
  role?: Role;
  search?: string;
  page?: number;
  limit?: number;
}

export interface UserListResult {
  users: User[];
  total: number;
  page: number;
  totalPages: number;
}
```

## Migrations

### Migration Best Practices

```bash
# ✅ Create migrations for schema changes
npx prisma migrate dev --name add_user_role

# ✅ Reset database in development
npx prisma migrate reset

# ✅ Deploy migrations to production
npx prisma migrate deploy
```

### Migration Files

```sql
-- ✅ Well-documented migration
-- Migration: Add user role enum and field
-- Created: 2024-01-15

-- Create enum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN', 'MODERATOR');

-- Add role column with default
ALTER TABLE "users" ADD COLUMN "role" "Role" NOT NULL DEFAULT 'USER';

-- Create index for role queries
CREATE INDEX "users_role_idx" ON "users"("role");
```

## Seeding

### Seed Data

```typescript
// ✅ Seed script with proper data
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Create admin user
  const admin = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {},
    create: {
      email: 'admin@example.com',
      name: 'Admin User',
      role: 'ADMIN',
    },
  });

  // Create sample posts
  const posts = await Promise.all([
    prisma.post.create({
      data: {
        title: 'First Post',
        content: 'This is the first post content.',
        published: true,
        authorId: admin.id,
      },
    }),
    prisma.post.create({
      data: {
        title: 'Second Post',
        content: 'This is the second post content.',
        published: false,
        authorId: admin.id,
      },
    }),
  ]);

  console.log({ admin, posts });
}

main()
  .catch(e => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

## Error Handling

### Prisma Error Handling

```typescript
// ✅ Handle Prisma errors properly
import { Prisma } from '@prisma/client';

export async function updateUser(id: string, data: UpdateUserData): Promise<User> {
  try {
    return await prisma.user.update({
      where: { id },
      data,
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        updatedAt: true,
      },
    });
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2025':
          throw new Error('User not found');
        case 'P2002':
          throw new Error('Email already exists');
        default:
          throw new Error('Database operation failed');
      }
    }
    throw error;
  }
}
```

## Performance

### Connection Management

```typescript
// ✅ Proper Prisma client setup
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

### Query Optimization

```typescript
// ✅ Use pagination for large datasets
export async function getUsersPaginated(filters: UserFilters): Promise<UserListResult> {
  const { role, search, page = 1, limit = 10 } = filters;

  const where: Prisma.UserWhereInput = {};

  if (role) {
    where.role = role;
  }

  if (search) {
    where.OR = [
      { name: { contains: search, mode: 'insensitive' } },
      { email: { contains: search, mode: 'insensitive' } },
    ];
  }

  const [users, total] = await Promise.all([
    prisma.user.findMany({
      where,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
      },
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
    }),
    prisma.user.count({ where }),
  ]);

  return {
    users,
    total,
    page,
    totalPages: Math.ceil(total / limit),
  };
}
```

    page,
    totalPages: Math.ceil(total / limit)

}
}

```

alwaysApply: false
---
```
